1. Run 01 was 1 run for ancestral admgs sample sizes 500, 1000, 2000, 4000 - for relcadilac, dcd, gfci - these can't directly be used since there was no thresholding - but they can be used to compare the impact of thresholding
2. Run 02 will be for 4 runs for the same as point 1 - so that in total they make 5 runs - can use commit b4a60cfd21c12864070a8a93fb07e6bb39521382 as reference - these can't directly be used since there was no thresholding - but they can be used to compare the impact of thresholding
3. Run 03 will be for ancestral admgs varying the number of nodes [5, 10, 15, 20, 30] - for relcadilac, dcd, gfci - can use commit 80a3c11c7c8103f8b00cc6c740584b8 as reference - these can't directly be used since there was no thresholding - but they can be used to compare the impact of thresholding
4. Run 04 is not a separate run, I have just combined the data from point 1 and point 2 to make a 5 run set for ancestral admgs with sample sizes 500, 1000, 2000, 4000 for relcadilac, dcd, gfci - these can't directly be used since there was no thresholding - but they can be used to compare the impact of thresholding
5. For the above graphs can use commit 00d1e5877176df94dee36ac21da393549a270a7f as reference (for code and everything)
6. Run 05 is just a single test of relcadilac to see how long 7 node 3000 sample size data takes to run --- it takes 3.4 minutes
7. In Run 06 I am again doing a 5 node 500 sample size test to see how the rewards returned by relcadilac are handled --- the rewards for this converges - which was quite obvious since during the end 500 sample ones speed up quite a bit meaning the LRU cache is being hit more
8. In run 07 I am trying to properly test the impact of sample size on the bic score - and how it compares with the ground truth bic - does the difference between the ground truth bic and the predicted bic (perhaps percentage difference) decrease as the sample size increases. I am also capturing some data on the average rewards to see whether 16000 is sufficient or I need to increase it. Only relcadilac in the runs with sample sizes [500, 600, 700, 1000, 1500, 2000, 2500, 3000] each of them run 10 times - all of them with 7 nodes.
9. In run 08 I am running the bow free admg model on the sachs data set - without thresholding
10. In run 09 I am running the same test as run 01, but with thresholding applied - but this is only for relcadilac since I have added the thresholding, and want to recalculate its metrics. In order to do a comparision we would have to merge the data -- can use commit aa1a554e7a5e1d7cca458782e50e76937af04cee for code reference - there was a mistake conducting this test - the thresholding was applied incorrectly - rather than applying it to just the magnitude, the full value was compared
11. In run 10, I am running the same test as run 09, but with the bug in the code corrected - in the thresholding function in the utils.py file - but I am running the loop just twice rather than 5 times since 5 times takes too long - can use commit f437c4b0a18112e5f87aa61d12eaa11a9a9ec6a1 for code reference
12. In run 11, I am doing num nodes variation [5, 10, 15, 20, 30] with 2000 sample size - each run 5 times with thresholding - for relcadilac, dcd, gfci for bow-free graphs
13. In run 12 I am doing sample size variation [500, 1000, 2000, 4000] - each run 5 times with thresholding - for relcadilac, dcd, gfci for bow-free graphs
14. In run 13, i am running an ancestral node 15, 2000 samples, 4000 steps_per_env, 4 degree run to see how long it takes and if the non-convergence issue is still present - only comparing dcd and relcadilac - the model converged - but still had a worse bic than dcd
15. In run 14 I am running an ancestral node 10, 4000 samples, 4000 steps_per_env, 4 degree run to see if the ground truth graph can be recovered or lower bic than the ground truth model can be obtained or if we can beat dcd on bic / shd / f1 score. we can beat dcd, but not obtain the lowest score.
16. in run 15 i am running an ancestral node 10, 4000 samples, 4000 steps_per_env, 4 degree run to see if it is possible to recover the true graph - and to see if it is possible to get a better bic than dcd.  - only relcadilac
17. In Run 16, I have provided the topo order to the model and the model must only find the edges. I wanted to see if the model performs better at this than before. The size and complexity of the search space is reduced. Everything else is default: 10 nodes, 4 degree, 2000 samples, 2000 steps_per_env, using thresholding - only relcadilac - this is incorrect and needs to be run again - I have just rerun it with the fix - I have run this again - and the topo order known method does perform better - but it is still not able to find the minimum bic graph - this is saved as ancestral_fraction_excess_bic_with_without_topo_order.png
18. In run 17, I have an alternative vec2admg function for bow-free graphs which I compare against my current formulation. The new method is called logits and my previous formulation is called hierarchical since it gives primacy to directed edges over undirected edges. I keep everything else default - 10 nodes, 4 degree, 2000 samples, 2000 steps_per_env, using thresholding, no topo order - only relcadilac - the logits formulation took double the time to run and gave results which were slightly worse than the hierarchical formulation (by 4 units on the BIC value)
19. In run 15 I am trying to figure out the impact of more steps_per_env (2000, 3000, 4000) on the excess bic value - how much the predicted bic is larger than the true bic - I am doing 3 runs per steps_per_env value. This is for 15 node, 4 degree, 2000 samples - this is only for dcd and relcadilac. This is for ancestral graphs.
